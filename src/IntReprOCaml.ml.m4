(* vim: ft=ocaml
 * Immediate representation of possible values, using a straightforward
 * algebraic data type. *)
# 5 "src/IntReprOCaml.ml.m4"
open Stdint
open Helpers

module SerData = SerDataBytes

type floatv = float and stringv = string and boolv = bool
and i8v = Int8.t and i16v = Int16.t and i32v = Int32.t and i64v = Int64.t and i128v = Int128.t
and u8v = Uint8.t and u16v = Uint16.t and u32v = Uint32.t and u64v = Uint64.t and u128v = Uint128.t

let length_of_stringv n = .< Uint32.of_int (String.length .~n) >.

(* Could GADT help with choose prototype while preserving tuples? *)
let choose b c1 c2 =
  .< if .~b then .~c1 else .~c2 >.

let fst a_b =
  .< let a, _ = .~a_b in a >.

let snd a_b =
  .< let _, b = .~a_b in b >.

let map_fst f a_b =
  .< let a, b = .~a_b in .~(f .<a>.), b >.

let map_pair ~fst ~snd a_b =
  .<
    let a, b = .~a_b in
    .~(fst .<a>.), .~(snd .<b>.)
  >.

let dword_eq (n : SerData.dword code) (m : SerData.dword code) = .< .~n = .~m >.
let size_ge (n : SerData.size code) (m : SerData.size code) = .< .~n >= .~m >.
let boolv_of_const n = n
let boolv_and n m = .< .~n && .~m >.
let boolv_or n m = .< .~n || .~m >.

type u8v_ = u8v

dnl We cannot functorize because that would leave some code with references
dnl to the module passed as parameter to the functor, which is meaningless in
dnl stage 1. So we use that other nice piece of technology to save typing.
define(EXPAND_NUMOPS,`dnl
(* Beginning of a block generated by M4 *)
# 48 "src/IntReprOCaml.ml.m4"
  type t = $1.t and boolv = bool and u8v = u8v_
  let zero = .< $1.zero >.
  let one = .< $1.one >.
  let to_u8v n = .< $1.to_uint8 .~n >.
  let of_u8v n = .< $1.of_uint8 .~n >.
  let eq n m = .< $1.compare .~n .~m = 0 >.
  let ne n m = .< $1.compare .~n .~m <> 0 >.
  let ge n m = .< $1.compare .~n .~m >= 0 >.
  let gt n m = .< $1.compare .~n .~m > 0 >.
  let add n m = .< $1.add .~n .~m >.
  let sub n m = .< $1.sub .~n .~m >.
  let mul n m = .< $1.mul .~n .~m >.
  let rem  n m = .< $1.rem .~n .~m >.
  let div n m = .< $1.div .~n .~m >.
  let shift_left n m = .< $1.shift_left .~n (Uint8.to_int .~m) >.
  let shift_right n m = .< $1.shift_right .~n (Uint8.to_int .~m) >.
  let to_byte n = .< $1.to_uint8 .~n >.
  let of_byte n = .< $1.of_uint8 .~n >.
  let to_boolv n = .< $1.compare .~n $1.zero <> 0 >.
  let of_boolv n = .< if .~n then $1.one else $1.zero >.
  (* End of a block generated by M4 *)')dnl
# 68 "src/IntReprOCaml.ml.m4"

module I8 =
struct
  EXPAND_NUMOPS(Int8)
  let of_const i = Int8.of_int i
end

module U8 =
struct
  EXPAND_NUMOPS(Uint8)
  let of_const i = Uint8.of_int i
end

module I16 =
struct
  EXPAND_NUMOPS(Int16)
  let of_const i = Int16.of_int i
  let to_word n = .< Int16.to_uint16 .~n >.
  let of_word n = .< Int16.of_uint16 .~n >.
end

module U16 =
struct
  EXPAND_NUMOPS(Uint16)
  let of_const i = Uint16.of_int i
  let to_word n = .< Uint16.to_uint16 .~n >.
  let of_word n = .< Uint16.of_uint16 .~n >.
end

module I32 =
struct
  EXPAND_NUMOPS(Int32)
  let of_const n = n
  let to_byte = to_u8v
  let of_byte = of_u8v
  let to_dword n = .< Int32.to_uint32 .~n >.
  let of_dword n = .< Int32.of_uint32 .~n >.
  let to_size n = .< Int32.to_int .~n >.
  let of_size n = .< Int32.of_int .~n >.
end

module U32 =
struct
  EXPAND_NUMOPS(Uint32)
  let of_const n = n
  let to_byte = to_u8v
  let of_byte = of_u8v
  let to_dword n = .< Uint32.to_uint32 .~n >.
  let of_dword n = .< Uint32.of_uint32 .~n >.
  let to_size n = .< Uint32.to_int .~n >.
  let of_size n = .< Uint32.of_int .~n >.
end

module I64 =
struct
  EXPAND_NUMOPS(Int64)
  let of_const n = n
  let to_qword n = .< Int64.to_uint64 .~n >.
  let of_qword n = .< Int64.of_uint64 .~n >.
end

module U64 =
struct
  EXPAND_NUMOPS(Uint64)
  let of_const n = n
  let to_qword n = .< Uint64.to_uint64 .~n >.
  let of_qword n = .< Uint64.of_uint64 .~n >.
end

module I128 =
struct
  EXPAND_NUMOPS(Int128)
  let of_const n = n
  let to_oword n = .< Int128.to_uint128 .~n >.
  let of_oword n = .< Int128.of_uint128 .~n >.
end

module U128 =
struct
  EXPAND_NUMOPS(Uint128)
  let of_const n = n
  let to_oword n = n
  let of_oword n = n
end

let stringv_of_bytes n = .< Bytes.to_string .~n >.
let bytes_of_stringv n = .< Bytes.of_string .~n >.

module Float =
struct
  (* Shortcuts: *)
  let of_bytes n =
    .<
      let s = Bytes.to_string .~n in
      try float_of_string s
      with e ->
        Format.eprintf "Cannot convert %S into a float@." s ;
        raise e
    >.

  let to_bytes n = .< Bytes.of_string (string_of_float.~n) >.

  let to_qword : floatv code -> SerData.qword code = fun _n -> .< todo "qword_of_float" >.
  let of_qword : SerData.qword code -> floatv code = fun _n -> .< todo "float_of_qword" >.
end

let read_while ~cond ~reduce v_p =
  .<
    let rec loop v p =
      let b = .~(SerDataBytes.peek_byte .<p>.) in
      if .~cond b then (
        let p = .~(SerDataBytes.add .<p>. .<1>.) in
        loop (.~reduce v b) p
      ) else v, p
    in
    let v, p = .~v_p in
    loop v p
  >.

let do_while ~cond ~loop ic vc =
  .<
    let rec loop_ v i =
      if .~cond v i then (
        let v, i = .~loop v i in
        loop_ v i
      ) else
        v
    in
    loop_ .~vc .~ic
  >.
