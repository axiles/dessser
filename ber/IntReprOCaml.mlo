(* vim: ft=ocaml
 * Immediate representation of possible values, using a straightforward
 * algebraic data type. *)
open Stdint
open Helpers

module SerData = SerDataBytes

type floatv = float and stringv = string and boolv = bool
and i8v = Int8.t and i16v = Int16.t and i32v = Int32.t and i64v = Int64.t and i128v = Int128.t
and u8v = Uint8.t and u16v = Uint16.t and u32v = Uint32.t and u64v = Uint64.t and u128v = Uint128.t

let length_of_stringv n = .< Uint32.of_int (String.length .~n) >.

(* Could GADT help with choose prototype while preserving tuples? *)
let choose b c1 c2 =
  .< if .~b then .~c1 else .~c2 >.

let fst a_b =
  .< let a, _ = .~a_b in a >.

let snd a_b =
  .< let _, b = .~a_b in b >.

let map_fst f a_b =
  .< let fst_a, fst_b = .~a_b in .~(f .<fst_a>.), fst_b >.

let map_pair ~fst ~snd a_b =
  .<
    let a, b = .~a_b in
    .~(fst .<a>.), .~(snd .<b>.)
  >.

let dword_eq (n : SerData.dword code) (m : SerData.dword code) = .< .~n = .~m >.
let size_ge (n : SerData.size code) (m : SerData.size code) = .< .~n >= .~m >.
let boolv_of_const n = n
let boolv_and n m = .< .~n && .~m >.
let boolv_or n m = .< .~n || .~m >.

type u8v_ = u8v

(* We cannot functorize because that would leave some code with references
   to the module passed as parameter to the functor, which is meaningless in
   stage 1. Therefore a compile time preprocessor is used: *)
#define EXPAND_NUMOPS(MOD) \
  type t = MOD.t and boolv = bool and u8v = u8v_ \
  let zero = .< MOD.zero >. \
  let one = .< MOD.one >. \
  let to_u8v n = .< MOD.to_uint8 .~n >. \
  let of_u8v n = .< MOD.of_uint8 .~n >. \
  (* Rely on proper implementation of the custom comparators of the generic \
   * comparison, that the compiler knows how to optimise in many cases:  *) \
  let eq n m = .< .~n = .~m >. \
  let ne n m = .< .~n <> .~m >. \
  let ge n m = .< .~n >= .~m >. \
  let gt n m = .< .~n > .~m >. \
  let add n m = .< MOD.add .~n .~m >. \
  let sub n m = .< MOD.sub .~n .~m >. \
  let mul n m = .< MOD.mul .~n .~m >. \
  let rem  n m = .< MOD.rem .~n .~m >. \
  let div n m = .< MOD.div .~n .~m >. \
  let shift_left n m = .< MOD.shift_left .~n (Uint8.to_int .~m) >. \
  let shift_right n m = .< MOD.shift_right .~n (Uint8.to_int .~m) >. \
  let to_byte n = .< MOD.to_uint8 .~n >. \
  let of_byte n = .< MOD.of_uint8 .~n >. \
  let to_boolv n = .< MOD.compare .~n MOD.zero <> 0 >. \
  let of_boolv n = .< if .~n then MOD.one else MOD.zero >.

module I8 =
struct
  EXPAND_NUMOPS(Int8)
  let of_const i = Int8.of_int i
end

module U8 =
struct
  EXPAND_NUMOPS(Uint8)
  let of_const i = Uint8.of_int i
end

module I16 =
struct
  EXPAND_NUMOPS(Int16)
  let of_const i = Int16.of_int i
  let to_word n = .< Int16.to_uint16 .~n >.
  let of_word n = .< Int16.of_uint16 .~n >.
end

module U16 =
struct
  EXPAND_NUMOPS(Uint16)
  let of_const i = Uint16.of_int i
  let to_word n = .< Uint16.to_uint16 .~n >.
  let of_word n = .< Uint16.of_uint16 .~n >.
end

module I32 =
struct
  EXPAND_NUMOPS(Int32)
  let of_const n = n
  let to_byte = to_u8v
  let of_byte = of_u8v
  let to_dword n = .< Int32.to_uint32 .~n >.
  let of_dword n = .< Int32.of_uint32 .~n >.
  let to_size n = .< Int32.to_int .~n >.
  let of_size n = .< Int32.of_int .~n >.
end

module U32 =
struct
  EXPAND_NUMOPS(Uint32)
  let of_const n = n
  let to_byte = to_u8v
  let of_byte = of_u8v
  let to_dword n = .< Uint32.to_uint32 .~n >.
  let of_dword n = .< Uint32.of_uint32 .~n >.
  let to_size n = .< Uint32.to_int .~n >.
  let of_size n = .< Uint32.of_int .~n >.
end

module I64 =
struct
  EXPAND_NUMOPS(Int64)
  let of_const n = n
  let to_qword n = .< Int64.to_uint64 .~n >.
  let of_qword n = .< Int64.of_uint64 .~n >.
end

module U64 =
struct
  EXPAND_NUMOPS(Uint64)
  let of_const n = n
  let to_qword n = .< Uint64.to_uint64 .~n >.
  let of_qword n = .< Uint64.of_uint64 .~n >.
end

module I128 =
struct
  EXPAND_NUMOPS(Int128)
  let of_const n = n
  let to_oword n = .< Int128.to_uint128 .~n >.
  let of_oword n = .< Int128.of_uint128 .~n >.
end

module U128 =
struct
  EXPAND_NUMOPS(Uint128)
  let of_const n = n
  let to_oword n = n
  let of_oword n = n
end

let stringv_of_bytes n = .< Bytes.to_string .~n >.
let bytes_of_stringv n = .< Bytes.of_string .~n >.

module Float =
struct
  (* Shortcuts: *)
  let of_bytes n =
    .<
      let s = Bytes.to_string .~n in
      try float_of_string s
      with e ->
        Format.eprintf "Cannot convert %S into a float@." s ;
        raise e
    >.

  let to_bytes n = .< Bytes.of_string (string_of_float.~n) >.

  let to_qword : floatv code -> SerData.qword code = fun _n -> .< todo "qword_of_float" >.
  let of_qword : SerData.qword code -> floatv code = fun _n -> .< todo "float_of_qword" >.
end

let read_while ~cond ~reduce v_p =
  .<
    let rec read_while_loop v p =
      let read_while_byte = .~(SerDataBytes.peek_byte .<p>.) in
      if .~cond read_while_byte then (
        let p = .~(SerDataBytes.add .<p>. .<1>.) in
        read_while_loop (.~reduce v read_while_byte) p
      ) else v, p
    in
    let v, p = .~v_p in
    read_while_loop v p
  >.

let do_while ~cond ~loop ic vc =
  .<
    let rec do_while_loop v i =
      if .~cond v i then (
        let v, i = .~loop v i in
        do_while_loop v i
      ) else
        v
    in
    do_while_loop .~vc .~ic
  >.
